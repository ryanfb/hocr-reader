[{"tags":[],"description":{"full":"<p>Davis - <a href='http://davisjs.com'>http://davisjs.com</a> - JavaScript Routing - 0.8.0<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - <a href='http://davisjs.com'>http://davisjs.com</a> - JavaScript Routing - 0.8.0<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":";"},{"tags":[{"type":"param","types":["Function"],"name":"config","description":"A function that will be run with a newly created Davis.App as its context,"},{"type":"should"},{"type":"namespace"},{"type":"returns"}],"description":{"full":"<p>Convinience method for instantiating a new Davis app and configuring it to use the passed<br />routes and subscriptions.</p>","summary":"<p>Convinience method for instantiating a new Davis app and configuring it to use the passed<br />routes and subscriptions.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Davis = function (config) {\n  var app = new Davis.App\n  config && config.call(app)\n  Davis.$(function () { app.start() })\n  return app\n};"},{"tags":[],"description":{"full":"<p>Stores the DOM library that Davis will use.  Can be overriden to use libraries other than jQuery.</p>","summary":"<p>Stores the DOM library that Davis will use.  Can be overriden to use libraries other than jQuery.</p>","body":""},"ignore":false,"code":"if (window.jQuery) {\n  Davis.$ = jQuery\n} else {\n  Davis.$ = null\n};"},{"tags":[{"type":"returns"}],"description":{"full":"<p>Checks whether Davis is supported in the current browser</p>","summary":"<p>Checks whether Davis is supported in the current browser</p>","body":""},"isPrivate":false,"ignore":false,"code":"Davis.supported = function () {\n  return (typeof window.history.pushState == 'function')\n}","ctx":{"type":"method","receiver":"Davis","name":"supported","string":"Davis.supported()"}},{"tags":[{"type":"private"},{"type":"returns"}],"description":{"full":"<p>A function that does nothing, used as a default param for any callbacks.</p>","summary":"<p>A function that does nothing, used as a default param for any callbacks.</p>","body":""},"isPrivate":false,"ignore":true,"code":"Davis.noop = function () {}","ctx":{"type":"method","receiver":"Davis","name":"noop","string":"Davis.noop()"}},{"tags":[{"type":"param","types":["Function"],"name":"extension","description":"the function that will extend Davis"},{"type":""},{"type":"Example:"},{"type":""}],"description":{"full":"<p>Method to extend the Davis library with an extension.</p>\n\n<p>An extension is just a function that will modify the Davis framework in some way,<br />for example changing how the routing works or adjusting where Davis thinks it is supported.</p>","summary":"<p>Method to extend the Davis library with an extension.</p>","body":"<p>An extension is just a function that will modify the Davis framework in some way,<br />for example changing how the routing works or adjusting where Davis thinks it is supported.</p>"},"isPrivate":false,"ignore":false,"code":"Davis.extend = function (extension) {\n  extension(Davis)\n}","ctx":{"type":"method","receiver":"Davis","name":"extend","string":"Davis.extend()"}},{"tags":[],"description":{"full":"<p>the version</p>","summary":"<p>the version</p>","body":""},"ignore":true,"code":"Davis.version = \"0.8.0\";","ctx":{"type":"property","receiver":"Davis","name":"version","value":"\"0.8.0\"","string":"Davis.version"}},{"tags":[],"description":{"full":"<p>Davis - utils<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - utils<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[],"description":{"full":"<p>A module that provides wrappers around modern JavaScript so that native implementations are used<br />whereever possible and JavaScript implementations are used in those browsers that do not natively<br />support them.</p>","summary":"<p>A module that provides wrappers around modern JavaScript so that native implementations are used<br />whereever possible and JavaScript implementations are used in those browsers that do not natively<br />support them.</p>","body":""},"ignore":true,"code":"Davis.utils = (function () {","ctx":{"type":"property","receiver":"Davis","name":"utils","value":"(function () {","string":"Davis.utils"}},{"tags":[{"type":"private"},{"type":"param","types":["array"],"name":"the","description":"array to loop through"},{"type":"param","types":["fn"],"name":"the","description":"function to that performs the every check"},{"type":"param","types":["thisp"],"name":"an","description":"optional param that will be set as fn's this value"},{"type":"returns"}],"description":{"full":"<p>A wrapper around native Array.prototype.every.</p>\n\n<p>Falls back to a pure JavaScript implementation in browsers that do not support Array.prototype.every.<br />For more details see the full docs on MDC <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every'>https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every</a></p>","summary":"<p>A wrapper around native Array.prototype.every.</p>","body":"<p>Falls back to a pure JavaScript implementation in browsers that do not support Array.prototype.every.<br />For more details see the full docs on MDC <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every'>https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every</a></p>"},"isPrivate":false,"ignore":true,"code":"if (Array.prototype.every) {\n    var every = function (array, fn) {\n      return array.every(fn, arguments[2])\n    }\n  } else {\n    var every = function (array, fn) {\n      if (array === void 0 || array === null) throw new TypeError();\n      var t = Object(array);\n      var len = t.length >>> 0;\n      if (typeof fn !== \"function\") throw new TypeError();\n\n      var thisp = arguments[2];\n      for (var i = 0; i < len; i++) {\n        if (i in t && !fn.call(thisp, t[i], i, t)) return false;\n      }\n\n      return true;\n    }\n  };"},{"tags":[{"type":"private"},{"type":"param","types":["array"],"name":"the","description":"array to loop through"},{"type":"param","types":["fn"],"name":"the","description":"function to apply to every element of the array"},{"type":"param","types":["thisp"],"name":"an","description":"optional param that will be set as fn's this value"},{"type":"returns"}],"description":{"full":"<p>A wrapper around native Array.prototype.forEach.</p>\n\n<p>Falls back to a pure JavaScript implementation in browsers that do not support Array.prototype.forEach.<br />For more details see the full docs on MDC <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach'>https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach</a></p>","summary":"<p>A wrapper around native Array.prototype.forEach.</p>","body":"<p>Falls back to a pure JavaScript implementation in browsers that do not support Array.prototype.forEach.<br />For more details see the full docs on MDC <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach'>https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach</a></p>"},"isPrivate":false,"ignore":true,"code":"if (Array.prototype.forEach) {\n    var forEach = function (array, fn) {\n      return array.forEach(fn, arguments[2])\n    }\n  } else {\n    var forEach = function (array, fn) {\n      if (array === void 0 || array === null) throw new TypeError();\n      var t = Object(array);\n      var len = t.length >>> 0;\n      if (typeof fn !== \"function\") throw new TypeError();\n      \n\n      var thisp = arguments[2];\n      for (var i = 0; i < len; i++) {\n        if (i in t) fn.call(thisp, t[i], i, t);\n      }\n    };\n  };"},{"tags":[{"type":"private"},{"type":"param","types":["array"],"name":"the","description":"array to filter"},{"type":"param","types":["fn"],"name":"the","description":"function to do the filtering"},{"type":"param","types":["thisp"],"name":"an","description":"optional param that will be set as fn's this value"},{"type":"returns"}],"description":{"full":"<p>A wrapper around native Array.prototype.filter.<br />Falls back to a pure JavaScript implementation in browsers that do not support Array.prototype.filter.<br />For more details see the full docs on MDC <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter'>https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter</a></p>","summary":"<p>A wrapper around native Array.prototype.filter.<br />Falls back to a pure JavaScript implementation in browsers that do not support Array.prototype.filter.<br />For more details see the full docs on MDC <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter'>https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter</a></p>","body":""},"isPrivate":false,"ignore":true,"code":"if (Array.prototype.filter) {\n    var filter = function (array, fn) {\n      return array.filter(fn, arguments[2])\n    }\n  } else {\n    var filter = function(array, fn) {\n      if (array === void 0 || array === null) throw new TypeError();\n      var t = Object(array);\n      var len = t.length >>> 0;\n      if (typeof fn !== \"function\") throw new TypeError();\n      \n\n      var res = [];\n      var thisp = arguments[2];\n      for (var i = 0; i < len; i++) {\n        if (i in t) {\n          var val = t[i]; // in case fn mutates this\n          if (fn.call(thisp, val, i, t)) res.push(val);\n        }\n      }\n\n      return res;\n    };\n  };"},{"tags":[{"type":"private"},{"type":"param","types":["args"],"name":"a","description":"functions arguments"},{"type":"param","types":["start"],"name":"an","description":"integer at which to start converting the arguments to an array"},{"type":"returns"}],"description":{"full":"<p>A convinience function for converting arguments to a proper array</p>","summary":"<p>A convinience function for converting arguments to a proper array</p>","body":""},"isPrivate":false,"ignore":true,"code":"var toArray = function (args, start) {\n    var start = start || 0\n    return Array.prototype.slice.call(args, start)\n  }","ctx":{"type":"function","name":"toArray","string":"toArray()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Exposing the public interface to the Utils module</p>","summary":"<p>Exposing the public interface to the Utils module</p>","body":""},"isPrivate":false,"ignore":true,"code":"return {\n    every: every,\n    forEach: forEach,\n    filter: filter,\n    toArray: toArray\n  }\n})()"},{"tags":[],"description":{"full":"<p>Davis - listener<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - listener<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[{"type":"module"}],"description":{"full":"<p>A module to bind to link clicks and form submits and turn what would normally be http requests<br />into instances of Davis.Request.  These request objects are then pushed onto the history stack<br />using the Davis.history module.</p>\n\n<p>This module requires jQuery for its event binding and event object normalization.  To use Davis<br />with any, or no, JavaScript framework this module should be replaced with one using your framework<br />of choice.</p>","summary":"<p>A module to bind to link clicks and form submits and turn what would normally be http requests<br />into instances of Davis.Request.  These request objects are then pushed onto the history stack<br />using the Davis.history module.</p>","body":"<p>This module requires jQuery for its event binding and event object normalization.  To use Davis<br />with any, or no, JavaScript framework this module should be replaced with one using your framework<br />of choice.</p>"},"isPrivate":false,"ignore":false,"code":"Davis.listener = function () {","ctx":{"type":"method","receiver":"Davis","name":"listener","string":"Davis.listener()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Methods to check whether an element has an href or action that is local to this page</p>","summary":"<p>Methods to check whether an element has an href or action that is local to this page</p>","body":""},"isPrivate":false,"ignore":true,"code":"var originChecks = {\n    A: function (elem) {\n      return elem.hostname !== window.location.host || elem.protocol !== window.location.protocol\n    },\n\n    FORM: function (elem) {\n      var a = document.createElement('a')\n      a.href = elem.action\n      return this.A(a)\n    }\n  }","ctx":{"type":"declaration","name":"originChecks","value":"{","string":"originChecks"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Checks whether the target of a click or submit event has an href or action that is local to the<br />current page.  Only links or targets with local hrefs or actions will be handled by davis, all<br />others will be ignored.</p>","summary":"<p>Checks whether the target of a click or submit event has an href or action that is local to the<br />current page.  Only links or targets with local hrefs or actions will be handled by davis, all<br />others will be ignored.</p>","body":""},"isPrivate":false,"ignore":true,"code":"var differentOrigin = function (elem) {\n    if (!originChecks[elem.nodeName.toUpperCase()]) return true // the elem is neither a link or a form\n    return originChecks[elem.nodeName.toUpperCase()](elem)\n  }","ctx":{"type":"function","name":"differentOrigin","string":"differentOrigin()"}},{"tags":[{"type":"param","types":["Function"],"name":"targetExtractor","description":"a function that will be called with the event target jQuery object and should return an object with path, title and method."},{"type":"private"}],"description":{"full":"<p>A handler that creates a new Davis.Request and pushes it onto the history stack using Davis.history.</p>","summary":"<p>A handler that creates a new Davis.Request and pushes it onto the history stack using Davis.history.</p>","body":""},"isPrivate":false,"ignore":true,"code":"var handler = function (targetExtractor) {\n    return function (event) {\n      if (differentOrigin(this)) return true\n      var request = new Davis.Request (targetExtractor.call(Davis.$(this)));\n      Davis.location.assign(request)\n      return false;\n    };\n  };","ctx":{"type":"function","name":"handler","string":"handler()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>A handler specialized for click events.  Gets the request details from a link elem</p>","summary":"<p>A handler specialized for click events.  Gets the request details from a link elem</p>","body":""},"isPrivate":false,"ignore":true,"code":"var clickHandler = handler(function () {\n    var self = this\n    return {\n      method: 'get',\n      fullPath: this.attr('href'),\n      title: this.attr('title'),\n      delegateToServer: function () {\n        window.location.pathname = self.attr('href')\n      }\n    };\n  });","ctx":{"type":"declaration","name":"clickHandler","value":"handler(function () {","string":"clickHandler"}},{"tags":[{"type":"private"}],"description":{"full":"<p>A handler specialized for submit events.  Gets the request details from a form elem</p>","summary":"<p>A handler specialized for submit events.  Gets the request details from a form elem</p>","body":""},"isPrivate":false,"ignore":true,"code":"var submitHandler = handler(function () {\n    var self = this\n    return {\n      method: this.attr('method'),\n      fullPath: decodeURI(this.serialize() ? [this.attr('action'), this.serialize()].join(\"?\") : this.attr('action')),\n      title: this.attr('title'),\n      delegateToServer: function () {\n        self.submit()\n      }\n    };\n  });","ctx":{"type":"declaration","name":"submitHandler","value":"handler(function () {","string":"submitHandler"}},{"tags":[{"type":"see","local":"Davis.App.settings","visibility":"Davis.App.settings"},{"type":"memberOf","parent":"listener"}],"description":{"full":"<p>Binds to both link clicks and form submits using jQuery's deleagate.</p>\n\n<p>Will catch all current and future links and forms.  Uses the apps settings for the selector to use for links and forms</p>","summary":"<p>Binds to both link clicks and form submits using jQuery's deleagate.</p>","body":"<p>Will catch all current and future links and forms.  Uses the apps settings for the selector to use for links and forms</p>"},"isPrivate":false,"ignore":false,"code":"this.listen = function () {\n    Davis.$(document).delegate(this.settings.formSelector, 'submit', submitHandler)\n    Davis.$(document).delegate(this.settings.linkSelector, 'click', clickHandler)\n  }","ctx":{"type":"method","receiver":"this","name":"listen","string":"this.listen()"}},{"tags":[{"type":"see","local":"Davis.App.settings","visibility":"Davis.App.settings"},{"type":"memberOf","parent":"listener"}],"description":{"full":"<p>Unbinds all click and submit handlers that were attatched with listen.</p>\n\n<p>Will efectivley stop the current app from processing any requests and all links and forms will have their default<br />behaviour restored.</p>","summary":"<p>Unbinds all click and submit handlers that were attatched with listen.</p>","body":"<p>Will efectivley stop the current app from processing any requests and all links and forms will have their default<br />behaviour restored.</p>"},"isPrivate":false,"ignore":false,"code":"this.unlisten = function () {\n    Davis.$(document).undelegate(this.settings.linkSelector, 'click', clickHandler)\n    Davis.$(document).undelegate(this.settings.formSelector, 'submit', submitHandler)\n  }\n}","ctx":{"type":"method","receiver":"this","name":"unlisten","string":"this.unlisten()"}},{"tags":[],"description":{"full":"<p>Davis - event<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - event<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[{"type":"module"}],"description":{"full":"<p>A module that can be mixed into any object to provide basic event functionality.</p>","summary":"<p>A module that can be mixed into any object to provide basic event functionality.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Davis.event = function () {","ctx":{"type":"method","receiver":"Davis","name":"event","string":"Davis.event()"}},{"tags":[],"description":{"full":"<p>callback storage</p>","summary":"<p>callback storage</p>","body":""},"ignore":true,"code":"var callbacks = {}","ctx":{"type":"declaration","name":"callbacks","value":"{}","string":"callbacks"}},{"tags":[{"type":"param","types":["String"],"name":"event","description":"event name"},{"type":"param","types":["Function"],"name":"fn","description":"callback"},{"type":"memberOf","parent":"event"}],"description":{"full":"<p>Binds a callback to a named event.</p>\n\n<p>The following events are triggered internally by Davis and can be bound to</p>\n\n<ul>\n<li>start : Triggered when the application is started</li>\n<li>lookupRoute : Triggered before looking up a route. The request being looked up is passed as an argument</li>\n<li>runRoute : Triggered before running a route. The request and route being run are passed as arguments</li>\n<li>routeNotFound : Triggered if no route for the current request can be found. The current request is passed as an arugment</li>\n<li>requestHalted : Triggered when a before filter halts the current request. The current request is passed as an argument</li>\n<li>unsupported : Triggered when starting a Davis app in a browser that doesn't support html5 pushState</li>\n</ul>\n\n<p>Example</p>\n\n<pre><code>app.bind('runRoute', function () {\n  console.log('about to run a route')\n})\n</code></pre>","summary":"<p>Binds a callback to a named event.</p>","body":"<p>The following events are triggered internally by Davis and can be bound to</p>\n\n<ul>\n<li>start : Triggered when the application is started</li>\n<li>lookupRoute : Triggered before looking up a route. The request being looked up is passed as an argument</li>\n<li>runRoute : Triggered before running a route. The request and route being run are passed as arguments</li>\n<li>routeNotFound : Triggered if no route for the current request can be found. The current request is passed as an arugment</li>\n<li>requestHalted : Triggered when a before filter halts the current request. The current request is passed as an argument</li>\n<li>unsupported : Triggered when starting a Davis app in a browser that doesn't support html5 pushState</li>\n</ul>\n\n<p>Example</p>\n\n<pre><code>app.bind('runRoute', function () {\n  console.log('about to run a route')\n})\n</code></pre>"},"isPrivate":false,"ignore":false,"code":"this.bind = function (event, fn) {\n    (callbacks[event] = callbacks[event] || []).push(fn);\n    return this;\n  };","ctx":{"type":"method","receiver":"this","name":"bind","string":"this.bind()"}},{"tags":[{"type":"param","types":["String"],"name":"event","description":"event name"},{"type":"param","types":["Mixed"],"name":"...","description":""},{"type":"memberOf","parent":"event"}],"description":{"full":"<p>Triggers an event with the given arguments.</p>","summary":"<p>Triggers an event with the given arguments.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.trigger = function (event) {\n    var args = Davis.utils.toArray(arguments, 1),\n        handlers = callbacks[event];\n\n    if (!handlers) return this\n\n    for (var i = 0, len = handlers.length; i < len; ++i) {\n      handlers[i].apply(this, args)\n    }\n\n    return this;\n  };\n}","ctx":{"type":"method","receiver":"this","name":"trigger","string":"this.trigger()"}},{"tags":[],"description":{"full":"<p>Davis - logger<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - logger<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[{"type":"module"}],"description":{"full":"<p>A module for enhancing the standard logging available through the console object.<br />Used internally in Davis and available for use outside of Davis.</p>\n\n<p>Generates log messages of varying severity in the format</p>\n\n<p><code>[Sun Jan 23 2011 16:15:21 GMT+0000 (GMT)] &lt;message&gt;</code></p>","summary":"<p>A module for enhancing the standard logging available through the console object.<br />Used internally in Davis and available for use outside of Davis.</p>","body":"<p>Generates log messages of varying severity in the format</p>\n\n<p><code>[Sun Jan 23 2011 16:15:21 GMT+0000 (GMT)] &lt;message&gt;</code></p>"},"isPrivate":false,"ignore":false,"code":"Davis.logger = function () {","ctx":{"type":"method","receiver":"Davis","name":"logger","string":"Davis.logger()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Generating the timestamp portion of the log message</p>","summary":"<p>Generating the timestamp portion of the log message</p>","body":""},"isPrivate":false,"ignore":true,"code":"function timestamp(){\n    return \"[\" + Date() + \"]\";\n  }","ctx":{"type":"function","name":"timestamp","string":"timestamp()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Pushing the timestamp onto the front of the arguments to log</p>","summary":"<p>Pushing the timestamp onto the front of the arguments to log</p>","body":""},"isPrivate":false,"ignore":true,"code":"function prepArgs(args) {\n    var a = Davis.utils.toArray(args)\n    a.unshift(timestamp())\n    return a.join(' ');\n  }\n\n  var logType = function (logLevel) {\n    return function () {\n      if (window.console) console[logLevel](prepArgs(arguments));\n    }\n  }","ctx":{"type":"function","name":"prepArgs","string":"prepArgs()"}},{"tags":[{"type":"params"},{"type":"memberOf","parent":"logger"}],"description":{"full":"<p>Prints an error message to the console if the console is available.</p>","summary":"<p>Prints an error message to the console if the console is available.</p>","body":""},"isPrivate":false,"ignore":false,"code":"var error = logType('error')","ctx":{"type":"declaration","name":"error","value":"logType('error')","string":"error"}},{"tags":[{"type":"params"},{"type":"memberOf","parent":"logger"}],"description":{"full":"<p>Prints an info message to the console if the console is available.</p>","summary":"<p>Prints an info message to the console if the console is available.</p>","body":""},"isPrivate":false,"ignore":false,"code":"var info = logType('info')","ctx":{"type":"declaration","name":"info","value":"logType('info')","string":"info"}},{"tags":[{"type":"params"},{"type":"memberOf","parent":"logger"}],"description":{"full":"<p>Prints a warning message to the console if the console is available.</p>","summary":"<p>Prints a warning message to the console if the console is available.</p>","body":""},"isPrivate":false,"ignore":false,"code":"var warn = logType('warn')","ctx":{"type":"declaration","name":"warn","value":"logType('warn')","string":"warn"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Exposes the public methods of the module</p>","summary":"<p>Exposes the public methods of the module</p>","body":""},"isPrivate":false,"ignore":true,"code":"this.logger = {\n    error: error,\n    info: info,\n    warn: warn\n  }\n}","ctx":{"type":"property","receiver":"this","name":"logger","value":"{","string":"this.logger"}},{"tags":[],"description":{"full":"<p>Davis - Route<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - Route<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":"Davis.Route = (function () {\n\n  var pathNameRegex = /:([\\w\\d]+)/g;\n  var pathNameReplacement = \"([^\\/]+)\";","ctx":{"type":"property","receiver":"Davis","name":"Route","value":"(function () {","string":"Davis.Route"}},{"tags":[{"type":"constructor"},{"type":"param","types":["String"],"name":"method","description":"This should be one of either 'get', 'post', 'put', 'delete', 'before', 'after' or 'state'"},{"type":"param","types":["String"],"name":"path","description":"This string can contain place holders for variables, e.g. '/user/:id'"},{"type":"param","types":["Function"],"name":"callback","description":"A callback that will be called when a request matching both the path and method is triggered."},{"type":""},{"type":"Example:"},{"type":""},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>Davis.Routes are the main part of a Davis application.  They consist of an HTTP method, a path<br />and a callback function.  When a link or a form that Davis has bound to are clicked or submitted<br />a request is pushed on the history stack and a route that matches the path and method of the<br />generated request is run.</p>\n\n<p>Inside the callback function 'this' is bound to the request.</p>","summary":"<p>Davis.Routes are the main part of a Davis application.  They consist of an HTTP method, a path<br />and a callback function.  When a link or a form that Davis has bound to are clicked or submitted<br />a request is pushed on the history stack and a route that matches the path and method of the<br />generated request is run.</p>","body":"<p>Inside the callback function 'this' is bound to the request.</p>"},"isPrivate":false,"ignore":false,"code":"var Route = function (method, path, callback) {\n    var convertPathToRegExp = function () {\n      if (!(path instanceof RegExp)) {\n        var str = path.replace(pathNameRegex, pathNameReplacement);\n\n        // Most browsers will reset this to zero after a replace call.  IE will\n        // set it to the index of the last matched character.\n        path.lastIndex = 0;\n\n        return new RegExp(\"^\" + str + \"$\", \"gi\");\n      } else {\n        return path;\n      };\n    };\n\n    var convertMethodToRegExp = function () {\n      if (!(method instanceof RegExp)) {\n        return new RegExp(\"^\" + method + \"$\", \"i\");\n      } else {\n        return method\n      };\n    }\n\n    var capturePathParamNames = function () {\n      var names = [], a;\n      while ((a = pathNameRegex.exec(path))) names.push(a[1]);\n      return names;\n    };\n\n    this.paramNames = capturePathParamNames();\n    this.path = convertPathToRegExp();\n    this.method = convertMethodToRegExp();\n    this.callback = callback;\n  }","ctx":{"type":"function","name":"Route","string":"Route()"}},{"tags":[{"type":"param","types":["String"],"name":"method","description":"the method to match against"},{"type":"param","types":["String"],"name":"path","description":"the path to match against"},{"type":"returns"},{"type":""},{"type":"Example:"},{"type":""},{"type":""}],"description":{"full":"<p>Tests whether or not a route matches a particular request.</p>","summary":"<p>Tests whether or not a route matches a particular request.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Route.prototype.match = function (method, path) {\n    this.reset();\n    return (this.method.test(method)) && (this.path.test(path))\n  }","ctx":{"type":"method","constructor":"Route","name":"match","string":"Route.prototype.match()"}},{"tags":[],"description":{"full":"<p>Resets the RegExps for method and path</p>","summary":"<p>Resets the RegExps for method and path</p>","body":""},"ignore":false,"code":"Route.prototype.reset = function () {\n    this.method.lastIndex = 0;\n    this.path.lastIndex = 0;\n  }","ctx":{"type":"method","constructor":"Route","name":"reset","string":"Route.prototype.reset()"}},{"tags":[{"type":"params"},{"type":"returns"},{"type":""},{"type":"Example:"},{"type":""},{"type":""}],"description":{"full":"<p>Runs the callback associated with a particular route against the passed request.</p>\n\n<p>Any named params in the request path are extracted, as per the routes path, and<br />added onto the requests params object.</p>","summary":"<p>Runs the callback associated with a particular route against the passed request.</p>","body":"<p>Any named params in the request path are extracted, as per the routes path, and<br />added onto the requests params object.</p>"},"isPrivate":false,"ignore":false,"code":"Route.prototype.run = function (request) {\n    this.reset();\n    var matches = this.path.exec(request.path);\n    if (matches) {\n      matches.shift();\n      for (var i=0; i < matches.length; i++) {\n        request.params[this.paramNames[i]] = matches[i];\n      };\n    };\n    return this.callback.call(request, request);\n    \n  }","ctx":{"type":"method","constructor":"Route","name":"run","string":"Route.prototype.run()"}},{"tags":[{"type":"returns"}],"description":{"full":"<p>Converts the route to a string representation of itself by combining the method and path<br />attributes.</p>","summary":"<p>Converts the route to a string representation of itself by combining the method and path<br />attributes.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Route.prototype.toString = function () {\n    return [this.method, this.path].join(' ');\n  }","ctx":{"type":"method","constructor":"Route","name":"toString","string":"Route.prototype.toString()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>exposing the constructor</p>","summary":"<p>exposing the constructor</p>","body":""},"isPrivate":false,"ignore":true,"code":"return Route;\n})()"},{"tags":[],"description":{"full":"<p>Davis - router<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - router<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[{"type":"module"}],"description":{"full":"<p>A decorator that adds convinience methods to a Davis.App for easily creating instances<br />of Davis.Route and looking up routes for a particular request.</p>\n\n<p>Provides get, post put and delete method shortcuts for creating instances of Davis.Routes<br />with the corresponding method.  This allows simple REST styled routing for a client side<br />JavaScript application.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.get('/foo/:id', function (req) {\n  // get the foo with id = req.params['id']\n})\n\napp.post('/foo', function (req) {\n  // create a new instance of foo with req.params\n})\n\napp.put('/foo/:id', function (req) {\n  // update the instance of foo with id = req.params['id']\n})\n\napp.del('/foo/:id', function (req) {\n  // delete the instance of foo with id = req.params['id']\n})\n</code></pre>\n\n<p>As well as providing convinience methods for creating instances of Davis.Routes the router<br />also provides methods for creating special instances of routes called filters.  Before filters<br />run before any matching route is run, and after filters run after any matched route has run.<br />A before filter can return false to halt the running of any matched routes or other before filters.</p>\n\n<p>A filter can take an optional path to match on, or without a path will match every request.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.before('/foo/:id', function (req) {\n  // will only run before request matching '/foo/:id'\n})\n\napp.before(function (req) {\n  // will run before all routes\n})\n\napp.after('/foo/:id', function (req) {\n  // will only run after routes matching '/foo/:id'\n})\n\napp.after(function (req) {\n  // will run after all routes\n})\n</code></pre>\n\n<p>Another special kind of route, called state routes, are also generated using the router.  State routes<br />are for requests that will not change the current page location.  Instead the page location will remain<br />the same but the current state of the page has changed.  This allows for states which the server will not<br />be expected to know about and support.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>\n\n<p>Using the <code>trans</code> method an app can transition to these kind of states without changing the url location.</p>","summary":"<p>A decorator that adds convinience methods to a Davis.App for easily creating instances<br />of Davis.Route and looking up routes for a particular request.</p>","body":"<p>Provides get, post put and delete method shortcuts for creating instances of Davis.Routes<br />with the corresponding method.  This allows simple REST styled routing for a client side<br />JavaScript application.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.get('/foo/:id', function (req) {\n  // get the foo with id = req.params['id']\n})\n\napp.post('/foo', function (req) {\n  // create a new instance of foo with req.params\n})\n\napp.put('/foo/:id', function (req) {\n  // update the instance of foo with id = req.params['id']\n})\n\napp.del('/foo/:id', function (req) {\n  // delete the instance of foo with id = req.params['id']\n})\n</code></pre>\n\n<p>As well as providing convinience methods for creating instances of Davis.Routes the router<br />also provides methods for creating special instances of routes called filters.  Before filters<br />run before any matching route is run, and after filters run after any matched route has run.<br />A before filter can return false to halt the running of any matched routes or other before filters.</p>\n\n<p>A filter can take an optional path to match on, or without a path will match every request.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.before('/foo/:id', function (req) {\n  // will only run before request matching '/foo/:id'\n})\n\napp.before(function (req) {\n  // will run before all routes\n})\n\napp.after('/foo/:id', function (req) {\n  // will only run after routes matching '/foo/:id'\n})\n\napp.after(function (req) {\n  // will run after all routes\n})\n</code></pre>\n\n<p>Another special kind of route, called state routes, are also generated using the router.  State routes<br />are for requests that will not change the current page location.  Instead the page location will remain<br />the same but the current state of the page has changed.  This allows for states which the server will not<br />be expected to know about and support.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>\n\n<p>Using the <code>trans</code> method an app can transition to these kind of states without changing the url location.</p>"},"isPrivate":false,"ignore":false,"code":"Davis.router = function () {","ctx":{"type":"method","receiver":"Davis","name":"router","string":"Davis.router()"}},{"tags":[{"type":"param","types":["String"],"name":"method","description":"The method for this route."},{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":""},{"type":"Example:"},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>Low level method for adding routes to your application.</p>\n\n<p>If called with just a method will return a partially applied function that can create routes with<br />that method.  This is used internally to provide shortcuts for get, post, put, delete and state<br />routes.</p>\n\n<p>You normally want to use the higher level methods such as get and post, but this can be useful for extending<br />Davis to work with other kinds of requests.</p>","summary":"<p>Low level method for adding routes to your application.</p>","body":"<p>If called with just a method will return a partially applied function that can create routes with<br />that method.  This is used internally to provide shortcuts for get, post, put, delete and state<br />routes.</p>\n\n<p>You normally want to use the higher level methods such as get and post, but this can be useful for extending<br />Davis to work with other kinds of requests.</p>"},"isPrivate":false,"ignore":false,"code":"this.route = function (method, path, handler) {\n    var createRoute = function (path, handler) {\n      var route = new Davis.Route (method, path, handler)\n      routeCollection.push(route)\n      return route\n    }\n\n    return (arguments.length == 1) ? createRoute : createRoute(path, handler)\n  }","ctx":{"type":"method","receiver":"this","name":"route","string":"this.route()"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating get routes.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating get routes.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.get  = this.route('get')","ctx":{"type":"property","receiver":"this","name":"get","value":"this.route('get')","string":"this.get"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating post routes.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating post routes.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.post = this.route('post')","ctx":{"type":"property","receiver":"this","name":"post","value":"this.route('post')","string":"this.post"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating put routes.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating put routes.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.put  = this.route('put')","ctx":{"type":"property","receiver":"this","name":"put","value":"this.route('put')","string":"this.put"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating delete routes.</p>\n\n<p>delete is a reserved word in javascript so use the <code>del</code> method when creating a Davis.Route with a method of delete.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating delete routes.</p>","body":"<p>delete is a reserved word in javascript so use the <code>del</code> method when creating a Davis.Route with a method of delete.</p>"},"isPrivate":false,"ignore":false,"code":"this.del  = this.route('delete')","ctx":{"type":"property","receiver":"this","name":"del","value":"this.route('delete')","string":"this.del"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route, this will never be seen in the url bar."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route"},{"type":"memberOf","parent":"router"},{"type":""},{"type":"Example:"},{"type":""},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>Adds a state route into the apps route collection.</p>\n\n<p>These special kind of routes are not triggered by clicking links or submitting forms, instead they<br />are triggered manually by calling <code>trans</code>.</p>\n\n<p>Routes added using the state method act in the same way as other routes except that they generate<br />a route that is listening for requests that will not change the page location.</p>","summary":"<p>Adds a state route into the apps route collection.</p>","body":"<p>These special kind of routes are not triggered by clicking links or submitting forms, instead they<br />are triggered manually by calling <code>trans</code>.</p>\n\n<p>Routes added using the state method act in the same way as other routes except that they generate<br />a route that is listening for requests that will not change the page location.</p>"},"isPrivate":false,"ignore":false,"code":"this.state = this.route('state');","ctx":{"type":"property","receiver":"this","name":"state","value":"this.route('state')","string":"this.state"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The path that represents this state. This will not be seen in the url bar."},{"type":"param","types":["Object"],"name":"data","description":"Any additional data that should be sent with the request as params."},{"type":"memberOf","parent":"router"},{"type":""},{"type":"Example:"},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>Transitions the app into the state identified by the passed path parameter.</p>\n\n<p>This allows the app to enter states without changing the page path through a link click or form submit. <br />If there are handlers registered for this state, added by the <code>state</code> method, they will be triggered.</p>\n\n<p>This method generates a request with a method of 'state', in all other ways this request is identical<br />to those that are generated when clicking links etc.</p>\n\n<p>States transitioned to using this method will not be able to be revisited directly with a page load as<br />there is no url that represents the state.</p>\n\n<p>An optional second parameter can be passed which will be available to any handlers in the requests<br />params object.</p>","summary":"<p>Transitions the app into the state identified by the passed path parameter.</p>","body":"<p>This allows the app to enter states without changing the page path through a link click or form submit. <br />If there are handlers registered for this state, added by the <code>state</code> method, they will be triggered.</p>\n\n<p>This method generates a request with a method of 'state', in all other ways this request is identical<br />to those that are generated when clicking links etc.</p>\n\n<p>States transitioned to using this method will not be able to be revisited directly with a page load as<br />there is no url that represents the state.</p>\n\n<p>An optional second parameter can be passed which will be available to any handlers in the requests<br />params object.</p>"},"isPrivate":false,"ignore":false,"code":"this.trans = function (path, data) {\n    if (data) {\n      var fullPath = [path, decodeURIComponent(Davis.$.param(data))].join('?')\n    } else {\n      var fullPath = path\n    };\n\n    var req = new Davis.Request({\n      method: 'state',\n      fullPath: fullPath,\n      title: ''\n    })\n\n    Davis.location.assign(req)\n  }","ctx":{"type":"method","receiver":"this","name":"trans","string":"this.trans()"}},{"tags":[],"description":{"full":"<p>Generating convinience methods for creating filters using Davis.Routes and methods to<br />lookup filters.</p>","summary":"<p>Generating convinience methods for creating filters using Davis.Routes and methods to<br />lookup filters.</p>","body":""},"ignore":true,"code":"this.filter = function (filterName) {\n    return function () {\n      var method = /.+/;\n\n      if (arguments.length == 1) {\n        var path = /.+/;\n        var handler = arguments[0];\n      } else if (arguments.length == 2) {\n        var path = arguments[0];\n        var handler = arguments[1];\n      };\n\n      var route = new Davis.Route (method, path, handler)\n      filterCollection[filterName].push(route);\n      return route\n    }\n  }\n\n  this.lookupFilter = function (filterType) {\n    return function (method, path) {\n      return Davis.utils.filter(filterCollection[filterType], function (route) {\n        return route.match(method, path)\n      });\n    }\n  }","ctx":{"type":"method","receiver":"this","name":"filter","string":"this.filter()"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.filter</code> for creating before filters.</p>","summary":"<p>A convinience wrapper around <code>app.filter</code> for creating before filters.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.before = this.filter('before')","ctx":{"type":"property","receiver":"this","name":"before","value":"this.filter('before')","string":"this.before"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.filter</code> for creating after filters.</p>","summary":"<p>A convinience wrapper around <code>app.filter</code> for creating after filters.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.after = this.filter('after')","ctx":{"type":"property","receiver":"this","name":"after","value":"this.filter('after')","string":"this.after"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up before filters.</p>","summary":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up before filters.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.lookupBeforeFilter = this.lookupFilter('before')","ctx":{"type":"property","receiver":"this","name":"lookupBeforeFilter","value":"this.lookupFilter('before')","string":"this.lookupBeforeFilter"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up after filters.</p>","summary":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up after filters.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.lookupAfterFilter  = this.lookupFilter('after')","ctx":{"type":"property","receiver":"this","name":"lookupAfterFilter","value":"this.lookupFilter('after')","string":"this.lookupAfterFilter"}},{"tags":[{"type":"private"}],"description":{"full":"<p>collections of routes and filters</p>","summary":"<p>collections of routes and filters</p>","body":""},"isPrivate":false,"ignore":true,"code":"var routeCollection = [];\n  var filterCollection = {\n    before: [],\n    after: []\n  };","ctx":{"type":"declaration","name":"routeCollection","value":"[]","string":"routeCollection"}},{"tags":[{"type":"param","types":["String"],"name":"method","description":"the method to use when looking up a route"},{"type":"param","types":["String"],"name":"path","description":"the path to use when looking up a route"},{"type":"returns"},{"type":"memberOf","parent":"router"}],"description":{"full":"<p>Looks for the first route that matches the method and path from a request.<br />Will only find and return the first matched route.</p>","summary":"<p>Looks for the first route that matches the method and path from a request.<br />Will only find and return the first matched route.</p>","body":""},"isPrivate":false,"ignore":false,"code":"this.lookupRoute = function (method, path) {\n    return Davis.utils.filter(routeCollection, function (route) {\n      return route.match(method, path)\n    })[0];\n  };\n}","ctx":{"type":"method","receiver":"this","name":"lookupRoute","string":"this.lookupRoute()"}},{"tags":[],"description":{"full":"<p>Davis - history<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - history<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[{"type":"module"}],"description":{"full":"<p>A module to normalize and enhance the window.pushState method and window.onpopstate event.</p>\n\n<p>Adds the ability to bind to whenever a new state is pushed onto the history stack and normalizes<br />both of these events into an onChange event.</p>","summary":"<p>A module to normalize and enhance the window.pushState method and window.onpopstate event.</p>","body":"<p>Adds the ability to bind to whenever a new state is pushed onto the history stack and normalizes<br />both of these events into an onChange event.</p>"},"isPrivate":false,"ignore":false,"code":"Davis.history = (function () {","ctx":{"type":"property","receiver":"Davis","name":"history","value":"(function () {","string":"Davis.history"}},{"tags":[{"type":"private"}],"description":{"full":"<p>storage for the push state handlers</p>","summary":"<p>storage for the push state handlers</p>","body":""},"isPrivate":false,"ignore":true,"code":"var pushStateHandlers = [];","ctx":{"type":"declaration","name":"pushStateHandlers","value":"[]","string":"pushStateHandlers"}},{"tags":[{"type":"private"}],"description":{"full":"<p>keep track of whether or not webkit like browsers have fired their initial<br />page load popstate</p>","summary":"<p>keep track of whether or not webkit like browsers have fired their initial<br />page load popstate</p>","body":""},"isPrivate":false,"ignore":true,"code":"var popped = false","ctx":{"type":"declaration","name":"popped","value":"false","string":"popped"}},{"tags":[{"type":"private"}],"description":{"full":"<p>method to check whether or not this is the first pop state event received</p>","summary":"<p>method to check whether or not this is the first pop state event received</p>","body":""},"isPrivate":false,"ignore":true,"code":"function hasPopped () {\n     if ('state' in window.history) {\n       return true\n     } else {\n       return popped\n     };\n   }"},{"tags":[{"type":"param","types":["Function"],"name":"handler","description":""},{"type":"private"}],"description":{"full":"<p>Add a handler to the push state event.  This event is not a native event but is fired<br />every time a call to pushState is called.</p>","summary":"<p>Add a handler to the push state event.  This event is not a native event but is fired<br />every time a call to pushState is called.</p>","body":""},"isPrivate":false,"ignore":true,"code":"function onPushState(handler) {\n    pushStateHandlers.push(handler);\n  };","ctx":{"type":"function","name":"onPushState","string":"onPushState()"}},{"tags":[{"type":"param","types":["Function"],"name":"handler","description":""},{"type":"private"}],"description":{"full":"<p>Simple wrapper for the native onpopstate event.</p>","summary":"<p>Simple wrapper for the native onpopstate event.</p>","body":""},"isPrivate":false,"ignore":true,"code":"function onPopState(handler) {\n    window.addEventListener('popstate', handler, true);\n  };","ctx":{"type":"function","name":"onPopState","string":"onPopState()"}},{"tags":[{"type":"param","types":["Function"],"name":"handler","description":""},{"type":"private"}],"description":{"full":"<p>returns a handler that wraps the native event given onpopstate.<br />When the page first loads or going back to a time in the history that was not added<br />by pushState the event.state object will be null.  This generates a request for the current<br />location in those cases</p>","summary":"<p>returns a handler that wraps the native event given onpopstate.<br />When the page first loads or going back to a time in the history that was not added<br />by pushState the event.state object will be null.  This generates a request for the current<br />location in those cases</p>","body":""},"isPrivate":false,"ignore":true,"code":"function wrapped(handler) {\n    return function (event) {\n      if (event.state && event.state._davis) {\n        handler(new Davis.Request(event.state._davis))\n      } else {\n        if (hasPopped()) handler(Davis.Request.forPageLoad())\n        popped = true\n      };\n    }\n  }","ctx":{"type":"function","name":"wrapped","string":"wrapped()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>provide a wrapper for any data that is going to be pushed into the history stack.  All<br />data is wrapped in a \"_davis\" namespace.</p>","summary":"<p>provide a wrapper for any data that is going to be pushed into the history stack.  All<br />data is wrapped in a \"_davis\" namespace.</p>","body":""},"isPrivate":false,"ignore":true,"code":"function wrapStateData(data) {\n    return {\"_davis\": data}\n  }","ctx":{"type":"function","name":"wrapStateData","string":"wrapStateData()"}},{"tags":[{"type":"param","types":["Function"],"name":"handler","description":"a function that will be called on push and pop state."},{"type":""},{"type":"The"},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"history"}],"description":{"full":"<p>Bind to the history on change event.</p>\n\n<p>This is not a native event but is fired any time a new state is pushed onto the history stack,<br />the current history is replaced or a state is popped off the history stack.</p>","summary":"<p>Bind to the history on change event.</p>","body":"<p>This is not a native event but is fired any time a new state is pushed onto the history stack,<br />the current history is replaced or a state is popped off the history stack.</p>"},"isPrivate":false,"ignore":false,"code":"function onChange(handler) {\n    onPushState(handler);\n    onPopState(wrapped(handler));\n  };","ctx":{"type":"function","name":"onChange","string":"onChange()"}},{"tags":[{"type":"param","types":["Davis.Request"],"name":"request","description":"the location to be assinged as the current location."},{"type":"memberOf","parent":"history"},{"type":""},{"type":"An"},{"type":"and"}],"description":{"full":"<p>Pushes a request onto the history stack.</p>\n\n<p>This is used internally by Davis to push a new request<br />resulting from either a form submit or a link click onto the history stack, it will also trigger<br />the onpushstate event.</p>","summary":"<p>Pushes a request onto the history stack.</p>","body":"<p>This is used internally by Davis to push a new request<br />resulting from either a form submit or a link click onto the history stack, it will also trigger<br />the onpushstate event.</p>"},"isPrivate":false,"ignore":false,"code":"function assign(request) {\n    history.pushState(wrapStateData(request.toJSON()), request.title, request.location());\n    Davis.utils.forEach(pushStateHandlers, function (handler) {\n      handler(request);\n    });\n  };","ctx":{"type":"function","name":"assign","string":"assign()"}},{"tags":[{"type":"param","types":["Davis.Request"],"name":"request","description":"the location to replace the current location with."},{"type":"memberOf","parent":"history"},{"type":""},{"type":"An"},{"type":"and"}],"description":{"full":"<p>Replace the current state on the history stack.</p>\n\n<p>This is used internally by Davis when performing a redirect.  This will trigger an onpushstate event.</p>","summary":"<p>Replace the current state on the history stack.</p>","body":"<p>This is used internally by Davis when performing a redirect.  This will trigger an onpushstate event.</p>"},"isPrivate":false,"ignore":false,"code":"function replace(request) {\n    history.replaceState(wrapStateData(request.toJSON()), request.title, request.location());\n    Davis.utils.forEach(pushStateHandlers, function (handler) {\n      handler(request);\n    });\n  };","ctx":{"type":"function","name":"replace","string":"replace()"}},{"tags":[{"type":"memberOf","parent":"history"}],"description":{"full":"<p>Returns the current location for the application.</p>\n\n<p>Davis.location delegates to this method for getting the apps current location.</p>","summary":"<p>Returns the current location for the application.</p>","body":"<p>Davis.location delegates to this method for getting the apps current location.</p>"},"isPrivate":false,"ignore":false,"code":"function current() {\n    return window.location.pathname + (window.location.search ? window.location.search : '')\n  }","ctx":{"type":"function","name":"current","string":"current()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Exposing the public methods of this module</p>","summary":"<p>Exposing the public methods of this module</p>","body":""},"isPrivate":false,"ignore":true,"code":"return {\n    onChange: onChange,\n    current: current,\n    assign: assign,\n    replace: replace\n  }\n})()"},{"tags":[],"description":{"full":"<p>Davis - location<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - location<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[{"type":"module"}],"description":{"full":"<p>A module that acts as a delegator to any locationDelegate implementation.  This abstracts the details of<br />what is being used for the apps routing away from the rest of the library.  This allows any kind of routing<br />To be used with Davis as long as it can respond appropriatly to the given delegate methods.</p>\n\n<p>A routing module must respond to the following methods</p>\n\n<ul>\n<li><strong>current</strong> : Should return the current location for the app</li>\n<li><strong>assign</strong> : Should set the current location of the app based on the location of the passed request.</li>\n<li><strong>replace</strong> : Should at least change the current location to the location of the passed request, for full compatibility it should not add any extra items in the history stack.</li>\n<li><strong>onChange</strong> : Should add calbacks that will be fired whenever the location is changed.</li>\n</ul>","summary":"<p>A module that acts as a delegator to any locationDelegate implementation.  This abstracts the details of<br />what is being used for the apps routing away from the rest of the library.  This allows any kind of routing<br />To be used with Davis as long as it can respond appropriatly to the given delegate methods.</p>","body":"<p>A routing module must respond to the following methods</p>\n\n<ul>\n<li><strong>current</strong> : Should return the current location for the app</li>\n<li><strong>assign</strong> : Should set the current location of the app based on the location of the passed request.</li>\n<li><strong>replace</strong> : Should at least change the current location to the location of the passed request, for full compatibility it should not add any extra items in the history stack.</li>\n<li><strong>onChange</strong> : Should add calbacks that will be fired whenever the location is changed.</li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"Davis.location = (function () {","ctx":{"type":"property","receiver":"Davis","name":"location","value":"(function () {","string":"Davis.location"}},{"tags":[],"description":{"full":"<p>By default the Davis uses the Davis.history module for its routing, this gives HTML5 based pushState routing<br />which is preferrable over location.hash based routing.</p>","summary":"<p>By default the Davis uses the Davis.history module for its routing, this gives HTML5 based pushState routing<br />which is preferrable over location.hash based routing.</p>","body":""},"ignore":true,"code":"var locationDelegate = Davis.history","ctx":{"type":"declaration","name":"locationDelegate","value":"Davis.history","string":"locationDelegate"}},{"tags":[{"type":"param","types":["Object"],"name":"the","description":"location delegate to use."},{"type":"memberOf","parent":"location"}],"description":{"full":"<p>Sets the current location delegate.</p>\n\n<p>The passed delegate will be used for all Davis apps.  The delegate<br />must respond to the following four methods <code>current</code>, <code>assign</code>, <code>replace</code> &amp; <code>onChange</code>.</p>","summary":"<p>Sets the current location delegate.</p>","body":"<p>The passed delegate will be used for all Davis apps.  The delegate<br />must respond to the following four methods <code>current</code>, <code>assign</code>, <code>replace</code> &amp; <code>onChange</code>.</p>"},"isPrivate":false,"ignore":false,"code":"function setLocationDelegate(delegate) {\n    locationDelegate = delegate\n  }","ctx":{"type":"function","name":"setLocationDelegate","string":"setLocationDelegate()"}},{"tags":[{"type":"memberOf","parent":"location"}],"description":{"full":"<p>Delegates to the locationDelegate.current method.</p>\n\n<p>This should return the current location of the app.</p>","summary":"<p>Delegates to the locationDelegate.current method.</p>","body":"<p>This should return the current location of the app.</p>"},"isPrivate":false,"ignore":false,"code":"function current() {\n    return locationDelegate.current()\n  }","ctx":{"type":"function","name":"current","string":"current()"}},{"tags":[{"type":"param","types":["Request"],"name":"req","description":"the request to set the current location to."},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"location"}],"description":{"full":"<p>Delegates to the locationDelegate.assign method.</p>\n\n<p>This should set the current location for the app to<br />that of the passed request object.</p>","summary":"<p>Delegates to the locationDelegate.assign method.</p>","body":"<p>This should set the current location for the app to<br />that of the passed request object.</p>"},"isPrivate":false,"ignore":false,"code":"function assign(req) {\n    locationDelegate.assign(req)\n  }","ctx":{"type":"function","name":"assign","string":"assign()"}},{"tags":[{"type":"param","types":["Request"],"name":"req","description":"the request to replace the current location with."},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"location"}],"description":{"full":"<p>Delegates to the locationDelegate.replace method.</p>\n\n<p>This should replace the current location with that of the passed request.<br />Ideally it should not create a new entry in the browsers history.</p>","summary":"<p>Delegates to the locationDelegate.replace method.</p>","body":"<p>This should replace the current location with that of the passed request.<br />Ideally it should not create a new entry in the browsers history.</p>"},"isPrivate":false,"ignore":false,"code":"function replace(req) {\n    locationDelegate.replace(req)\n  }","ctx":{"type":"function","name":"replace","string":"replace()"}},{"tags":[{"type":"param","types":["Function"],"name":"handler","description":"callback function to be called on location chnage."},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"location"}],"description":{"full":"<p>Delegates to the locationDelegate.onChange method.</p>\n\n<p>This should add a callback that will be called any time the location changes.<br />The handler function will be called with a request param which is an instance of Davis.Request.</p>","summary":"<p>Delegates to the locationDelegate.onChange method.</p>","body":"<p>This should add a callback that will be called any time the location changes.<br />The handler function will be called with a request param which is an instance of Davis.Request.</p>"},"isPrivate":false,"ignore":false,"code":"function onChange(handler) {\n    locationDelegate.onChange(handler)\n  }","ctx":{"type":"function","name":"onChange","string":"onChange()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Exposing the public methods of this module</p>","summary":"<p>Exposing the public methods of this module</p>","body":""},"isPrivate":false,"ignore":true,"code":"return {\n    setLocationDelegate: setLocationDelegate,\n    current: current,\n    assign: assign,\n    replace: replace,\n    onChange: onChange\n  }\n})()"},{"tags":[],"description":{"full":"<p>Davis - Request<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - Request<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":"Davis.Request = (function () {","ctx":{"type":"property","receiver":"Davis","name":"Request","value":"(function () {","string":"Davis.Request"}},{"tags":[{"type":"constructor"},{"type":"param","types":["Object"],"name":"raw","description":"An object that at least contains a title, fullPath and method proprty."},{"type":""},{"type":"Example"},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>Davis.Requests are created from click and submit events.  Davis.Requests are passed to Davis.Routes<br />and are stored in the history stack.  They are instantiated by the Davis.listener module.</p>\n\n<p>A request will have a params object which will contain all query params and form params, any named<br />params in a routes path will also be added to the requests params object.  Also included is support<br />for rails style nested form params.</p>\n\n<p>By default the request method will be taken from the method attribute for forms or will be defaulted<br />to 'get' for links, however there is support for using a hidden field called _method in your forms<br />to set the correct reqeust method.</p>","summary":"<p>Davis.Requests are created from click and submit events.  Davis.Requests are passed to Davis.Routes<br />and are stored in the history stack.  They are instantiated by the Davis.listener module.</p>","body":"<p>A request will have a params object which will contain all query params and form params, any named<br />params in a routes path will also be added to the requests params object.  Also included is support<br />for rails style nested form params.</p>\n\n<p>By default the request method will be taken from the method attribute for forms or will be defaulted<br />to 'get' for links, however there is support for using a hidden field called _method in your forms<br />to set the correct reqeust method.</p>"},"isPrivate":false,"ignore":false,"code":"var Request = function (opts) {\n    var raw = Davis.$.extend({}, {\n      title: \"\",\n      fullPath: \"\",\n      method: \"get\"\n    }, opts)\n\n    var self = this;\n    this.raw = raw;\n    this.params = {};\n    this.title = raw.title;\n    this.queryString = raw.fullPath.split(\"?\")[1];\n    this._staleCallback = function () {};\n\n    if (this.queryString) {\n      Davis.utils.forEach(this.queryString.split(\"&\"), function (keyval) {\n        var paramName = keyval.split(\"=\")[0],\n            paramValue = keyval.split(\"=\")[1],\n            nestedParamRegex = /^(\\w+)\\[(\\w+)?\\](\\[\\])?/,\n            nested;\n        if (nested = nestedParamRegex.exec(paramName)) {\n          var paramParent = nested[1];\n          var paramName = nested[2];\n          var isArray = !!nested[3];\n          var parentParams = self.params[paramParent] || {};\n\n          if (isArray) {\n            parentParams[paramName] = parentParams[paramName] || [];\n            parentParams[paramName].push(paramValue);\n            self.params[paramParent] = parentParams;\n          } else if (!paramName && !isArray) {\n            parentParams = self.params[paramParent] || []\n            parentParams.push(paramValue)\n            self.params[paramParent] = parentParams\n          } else {\n            parentParams[paramName] = paramValue;\n            self.params[paramParent] = parentParams;\n          }\n        } else {\n          self.params[paramName] = paramValue;\n        };\n\n      });\n    };\n\n    raw.fullPath = raw.fullPath.replace(/^https?:\\/\\/.+?\\//, '/');\n\n    this.method = (this.params._method || raw.method).toLowerCase();\n\n    this.path = raw.fullPath\n      .replace(/\\?.+$/, \"\")  // Remove the query string\n      .replace(/^https?:\\/\\/[^\\/]+/, \"\"); // Remove the protocol and host parts\n  \n    this.fullPath = raw.fullPath;\n\n    this.delegateToServer = raw.delegateToServer || Davis.noop;\n    this.isForPageLoad = raw.forPageLoad || false;\n\n    if (Request.prev) Request.prev.makeStale(this);\n    Request.prev = this;\n\n  };","ctx":{"type":"function","name":"Request","string":"Request()"}},{"tags":[{"type":"param","types":["String"],"name":"path","description":"The path to redirect the current request to"},{"type":"memberOf","parent":"Request"},{"type":""},{"type":"Example"},{"type":""},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>Redirects the current request to a new location.</p>\n\n<p>Calling redirect on an instance of Davis.Request will create a new request using the path and<br />title of the current request. Redirected requests always have a method of 'get'.</p>\n\n<p>The request created will replace the current request in the history stack.  Redirect is most<br />often useful inside a handler for a form submit.  After succesfully handling the form the app<br />can redirect to another path.  This means that the current form will not be re-submitted if<br />navigating through the history with the back or forward buttons because the request that the<br />submit generated has been replaced in the history stack.</p>","summary":"<p>Redirects the current request to a new location.</p>","body":"<p>Calling redirect on an instance of Davis.Request will create a new request using the path and<br />title of the current request. Redirected requests always have a method of 'get'.</p>\n\n<p>The request created will replace the current request in the history stack.  Redirect is most<br />often useful inside a handler for a form submit.  After succesfully handling the form the app<br />can redirect to another path.  This means that the current form will not be re-submitted if<br />navigating through the history with the back or forward buttons because the request that the<br />submit generated has been replaced in the history stack.</p>"},"isPrivate":false,"ignore":false,"code":"Request.prototype.redirect = function (path) {\n    Davis.location.replace(new Request ({\n      method: 'get',\n      fullPath: path,\n      title: this.title\n    }));\n  };","ctx":{"type":"method","constructor":"Request","name":"redirect","string":"Request.prototype.redirect()"}},{"tags":[{"type":"param","types":["Function"],"name":"callback","description":"A single callback that will be called when the request becomes stale."},{"type":"memberOf","parent":"Request"},{"type":""},{"type":"Example"},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>Adds a callback to be called when the request is stale.<br />A request becomes stale when it is no longer the current request, this normally occurs when a<br />new request is triggered.  A request can be marked as stale manually if required.  The callback<br />passed to whenStale will be called with the new request that is making the current request stale.</p>\n\n<p>Use the whenStale callback to 'teardown' the objects required for the current route, this gives<br />a chance for views to hide themselves and unbind any event handlers etc.</p>","summary":"<p>Adds a callback to be called when the request is stale.<br />A request becomes stale when it is no longer the current request, this normally occurs when a<br />new request is triggered.  A request can be marked as stale manually if required.  The callback<br />passed to whenStale will be called with the new request that is making the current request stale.</p>","body":"<p>Use the whenStale callback to 'teardown' the objects required for the current route, this gives<br />a chance for views to hide themselves and unbind any event handlers etc.</p>"},"isPrivate":false,"ignore":false,"code":"Request.prototype.whenStale = function (callback) {\n    this._staleCallback = callback;\n  }","ctx":{"type":"method","constructor":"Request","name":"whenStale","string":"Request.prototype.whenStale()"}},{"tags":[{"type":"param","types":["Davis.Request"],"name":"req","description":"The next request that has been recieved."},{"type":"memberOf","parent":"Request"}],"description":{"full":"<p>Mark the request as stale.</p>\n\n<p>This will cause the whenStale callback to be called.</p>","summary":"<p>Mark the request as stale.</p>","body":"<p>This will cause the whenStale callback to be called.</p>"},"isPrivate":false,"ignore":false,"code":"Request.prototype.makeStale = function (req) {\n    this._staleCallback.call(req, req);\n  }","ctx":{"type":"method","constructor":"Request","name":"makeStale","string":"Request.prototype.makeStale()"}},{"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"description":{"full":"<p>Returns the location or path that should be pushed onto the history stack. </p>\n\n<p>For get requests this will be the same as the path, for post, put, delete and state requests this will<br />be blank as no location should be pushed onto the history stack.</p>","summary":"<p>Returns the location or path that should be pushed onto the history stack. </p>","body":"<p>For get requests this will be the same as the path, for post, put, delete and state requests this will<br />be blank as no location should be pushed onto the history stack.</p>"},"isPrivate":false,"ignore":false,"code":"Request.prototype.location = function () {\n    return (this.method === 'get') ? this.fullPath : ''\n  }","ctx":{"type":"method","constructor":"Request","name":"location","string":"Request.prototype.location()"}},{"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"description":{"full":"<p>Converts the request to a string representation of itself by combining the method and fullPath<br />attributes.</p>","summary":"<p>Converts the request to a string representation of itself by combining the method and fullPath<br />attributes.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Request.prototype.toString = function () {\n    return [this.method.toUpperCase(), this.path].join(\" \")\n  };","ctx":{"type":"method","constructor":"Request","name":"toString","string":"Request.prototype.toString()"}},{"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"description":{"full":"<p>Converts the request to a plain object which can be converted to a JSON string.</p>\n\n<p>Used when pushing a request onto the history stack.</p>","summary":"<p>Converts the request to a plain object which can be converted to a JSON string.</p>","body":"<p>Used when pushing a request onto the history stack.</p>"},"isPrivate":false,"ignore":false,"code":"Request.prototype.toJSON = function () {\n    return {\n      title: this.raw.title,\n      fullPath: this.raw.fullPath,\n      method: this.raw.method\n    }\n  }","ctx":{"type":"method","constructor":"Request","name":"toJSON","string":"Request.prototype.toJSON()"}},{"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"description":{"full":"<p>Creates a new request for the page on page load.</p>\n\n<p>This is required because usually requests are generated from clicking links or submitting forms<br />however this doesn't happen on a page load but should still be considered a request that the <br />JavaScript app should handle.</p>","summary":"<p>Creates a new request for the page on page load.</p>","body":"<p>This is required because usually requests are generated from clicking links or submitting forms<br />however this doesn't happen on a page load but should still be considered a request that the <br />JavaScript app should handle.</p>"},"isPrivate":false,"ignore":false,"code":"Request.forPageLoad = function () {\n    return new this ({\n      method: 'get',\n      // fullPath: window.location.pathname,\n      fullPath: Davis.location.current(),\n      title: document.title,\n      forPageLoad: true\n    });\n  }","ctx":{"type":"method","receiver":"Request","name":"forPageLoad","string":"Request.forPageLoad()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>Stores the last request</p>","summary":"<p>Stores the last request</p>","body":""},"isPrivate":false,"ignore":true,"code":"Request.prev = null\n\n  return Request\n\n})()","ctx":{"type":"property","receiver":"Request","name":"prev","value":"null","string":"Request.prev"}},{"tags":[],"description":{"full":"<p>Davis - App<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Davis - App<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":"Davis.App = (function () {","ctx":{"type":"property","receiver":"Davis","name":"App","value":"(function () {","string":"Davis.App"}},{"tags":[{"type":"constructor"},{"type":"returns"}],"description":{"full":"<p>Constructor for Davis.App</p>","summary":"<p>Constructor for Davis.App</p>","body":""},"isPrivate":false,"ignore":false,"code":"function App() {\n    this.running = false;\n    this.boundToInternalEvents = false;\n\n    this.use(Davis.listener)\n    this.use(Davis.event)\n    this.use(Davis.router)\n    this.use(Davis.logger)\n  };","ctx":{"type":"function","name":"App","string":"App()"}},{"tags":[{"type":"param","types":["Function"],"name":"config","description":"This function will be executed with the context bound to the apps setting object, this will also be passed as the first argument to the function."},{"type":""},{"type":"Example:"},{"type":""},{"type":""},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>A convinience function for changing the apps default settings.</p>\n\n<p>Should be used before starting the app to ensure any new settings<br />are picked up and used.</p>","summary":"<p>A convinience function for changing the apps default settings.</p>","body":"<p>Should be used before starting the app to ensure any new settings<br />are picked up and used.</p>"},"isPrivate":false,"ignore":false,"code":"App.prototype.configure = function(config) {\n    config.call(this.settings, this.settings);\n  };","ctx":{"type":"method","constructor":"App","name":"configure","string":"App.prototype.configure()"}},{"tags":[{"type":"param","types":["Function"],"name":"plugin","description":"The plugin to use"},{"type":""},{"type":"Example:"},{"type":""}],"description":{"full":"<p>Method to include a plugin in this app.</p>\n\n<p>A plugin is just a function that will be evaluated in the context of the app.</p>","summary":"<p>Method to include a plugin in this app.</p>","body":"<p>A plugin is just a function that will be evaluated in the context of the app.</p>"},"isPrivate":false,"ignore":false,"code":"App.prototype.use = function(plugin) {\n    plugin.apply(this, Davis.utils.toArray(arguments, 1))\n  };","ctx":{"type":"method","constructor":"App","name":"use","string":"App.prototype.use()"}},{"tags":[{"type":"param","types":["Object"],"name":"helpers","description":"An object containing helpers to mixin to the request"}],"description":{"full":"<p>Method to add helper properties to all requests in the application.</p>\n\n<p>Helpers will be added to the Davis.Request.prototype.  Care should be taken not to override any existing Davis.Request<br />methods.</p>","summary":"<p>Method to add helper properties to all requests in the application.</p>","body":"<p>Helpers will be added to the Davis.Request.prototype.  Care should be taken not to override any existing Davis.Request<br />methods.</p>"},"isPrivate":false,"ignore":false,"code":"App.prototype.helpers = function(helpers) {\n    for (property in helpers) {\n      if (helpers.hasOwnProperty(property)) Davis.Request.prototype[property] = helpers[property]\n    }\n  };","ctx":{"type":"method","constructor":"App","name":"helpers","string":"App.prototype.helpers()"}},{"tags":[{"type":"see","local":"#configure","visibility":"#configure"}],"description":{"full":"<p>Settings for the app.  These may be overriden directly or by using the configure<br />convinience method.</p>\n\n<p><code>linkSelector</code> is the jquery selector for all the links on the page that you want<br />Davis to respond to.  These links will not trigger a normal http request.</p>\n\n<p><code>formSelector</code> is similar to link selector but for all the forms that davis will bind to</p>\n\n<p><code>throwErrors</code> decides whether or not any errors will be caugth by Davis.  If this is set to true<br />errors will be thrown so that the request will not be handled by JavaScript, the server will have<br />to provide a response.  When set to false errors in a route will be caught and the server will not<br />receive the request.</p>\n\n<p><code>handleRouteNotFound</code> determines whether or not Davis should handle requests when there is no matching<br />route.  If set to false Davis will allow the request to be passed to your server to handle if no matching<br />route can be found.</p>\n\n<p><code>generateRequestOnPageLoad</code> determines whether a request should be generated for the initial page load.<br />by default this is set to false. A Davis.Request will not be generated with the path of the current<br />page.  Setting this to true will cause a request to be passed to your app for the inital page load.</p>","summary":"<p>Settings for the app.  These may be overriden directly or by using the configure<br />convinience method.</p>","body":"<p><code>linkSelector</code> is the jquery selector for all the links on the page that you want<br />Davis to respond to.  These links will not trigger a normal http request.</p>\n\n<p><code>formSelector</code> is similar to link selector but for all the forms that davis will bind to</p>\n\n<p><code>throwErrors</code> decides whether or not any errors will be caugth by Davis.  If this is set to true<br />errors will be thrown so that the request will not be handled by JavaScript, the server will have<br />to provide a response.  When set to false errors in a route will be caught and the server will not<br />receive the request.</p>\n\n<p><code>handleRouteNotFound</code> determines whether or not Davis should handle requests when there is no matching<br />route.  If set to false Davis will allow the request to be passed to your server to handle if no matching<br />route can be found.</p>\n\n<p><code>generateRequestOnPageLoad</code> determines whether a request should be generated for the initial page load.<br />by default this is set to false. A Davis.Request will not be generated with the path of the current<br />page.  Setting this to true will cause a request to be passed to your app for the inital page load.</p>"},"isPrivate":false,"ignore":false,"code":"App.prototype.settings = {\n    linkSelector: 'a',\n    formSelector: 'form',\n    throwErrors: true,\n    handleRouteNotFound: false,\n    generateRequestOnPageLoad: false\n  };","ctx":{"type":"property","constructor":"App","name":"settings","value":"{","string":"App.prototypesettings"}},{"tags":[],"description":{"full":"<p>Starts the app's routing.</p>\n\n<p>Apps created using the convinience Davis() function are automatically started.</p>\n\n<p>Starting the app binds all links and forms, so clicks and submits<br />create Davis requests that will be pushed onto the browsers history stack.  Browser history change<br />events will be picked up and the request that caused the change will be matched against the apps<br />routes and filters.</p>","summary":"<p>Starts the app's routing.</p>","body":"<p>Apps created using the convinience Davis() function are automatically started.</p>\n\n<p>Starting the app binds all links and forms, so clicks and submits<br />create Davis requests that will be pushed onto the browsers history stack.  Browser history change<br />events will be picked up and the request that caused the change will be matched against the apps<br />routes and filters.</p>"},"ignore":false,"code":"App.prototype.start = function(){\n    var self = this;\n\n    if (this.running) return\n\n    if (!Davis.supported()) {\n      this.trigger('unsupported')\n      return\n    };\n\n    var runFilterWith = function (request) {\n      return function (filter) {\n        var result = filter.run(request, request);\n        return (typeof result === \"undefined\" || result);\n      }\n    }\n\n    var beforeFiltersPass = function (request) {\n      return Davis.utils.every(\n        self.lookupBeforeFilter(request.method, request.path),\n        runFilterWith(request)\n      )\n    }\n\n    var handleRequest = function (request) {\n      if (beforeFiltersPass(request)) {\n        self.trigger('lookupRoute', request)\n        var route = self.lookupRoute(request.method, request.path);\n        if (route) {\n          self.trigger('runRoute', request, route);\n\n          try {\n            route.run(request)\n            self.trigger('routeComplete', request, route)\n          } catch (error) {\n            self.trigger('routeError', request, route, error)\n          }\n\n          Davis.utils.every(\n            self.lookupAfterFilter(request.method, request.path),\n            runFilterWith(request)\n          );\n\n        } else {\n          self.trigger('routeNotFound', request);\n        }\n      } else {\n        self.trigger('requestHalted', request)\n      }\n    }\n\n    var bindToInternalEvents = function () {\n      self\n        .bind('runRoute', function (request) {\n          self.logger.info(\"runRoute: \" + request.toString());\n        })\n        .bind('routeNotFound', function (request) {\n          if (!self.settings.handleRouteNotFound && !request.isForPageLoad) {\n            self.stop()\n            request.delegateToServer()\n          };\n          self.logger.warn(\"routeNotFound: \" + request.toString());\n        })\n        .bind('start', function () {\n          self.logger.info(\"application started\")\n        })\n        .bind('stop', function () {\n          self.logger.info(\"application stopped\")\n        })\n        .bind('routeError', function (request, route, error) {\n          if (self.settings.throwErrors) throw(error)\n          self.logger.error(error.message, error.stack)\n        });\n\n      Davis.location.onChange(function (req) {\n        handleRequest(req)\n      });\n\n      self.boundToInternalEvents = true\n    }\n\n    if (!this.boundToInternalEvents) bindToInternalEvents()\n\n    this.listen();\n    this.trigger('start')\n    this.running = true;\n\n    if (this.settings.generateRequestOnPageLoad) handleRequest(Davis.Request.forPageLoad())\n\n  };","ctx":{"type":"method","constructor":"App","name":"start","string":"App.prototype.start()"}},{"tags":[],"description":{"full":"<p>Stops the app's routing.</p>\n\n<p>Stops the app listening to clicks and submits on all forms and links found using the current<br />apps settings.</p>","summary":"<p>Stops the app's routing.</p>","body":"<p>Stops the app listening to clicks and submits on all forms and links found using the current<br />apps settings.</p>"},"ignore":false,"code":"App.prototype.stop = function() {\n    this.unlisten();\n    this.trigger('stop')\n    this.running = false\n  };\n\n  return App;\n})()","ctx":{"type":"method","constructor":"App","name":"stop","string":"App.prototype.stop()"}}]